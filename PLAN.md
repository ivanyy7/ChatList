# План реализации программы ChatList

## Этап 1: Подготовка проекта и структуры

1.1. Создать структуру проекта:
- `main.py` - главный файл с GUI интерфейсом
- `db.py` - модуль для работы с базой данных SQLite
- `models.py` - модуль для работы с моделями нейросетей
- `network.py` - модуль для отправки HTTP-запросов к API
- `config.py` - модуль для работы с настройками и переменными окружения
- `.env` - файл с API-ключами (добавить в .gitignore)
- `requirements.txt` - зависимости проекта

1.2. Установить зависимости:
- PyQt5 для GUI
- requests/httpx для HTTP-запросов
- python-dotenv для работы с .env файлом
- sqlite3 (встроенная библиотека Python)

## Этап 2: Реализация базы данных (db.py)

2.1. Создать функции инициализации БД:
- `init_database()` - создание файла БД и всех таблиц
- Проверка существования БД при первом запуске

2.2. Реализовать CRUD операции для таблицы `prompts`:
- `create_prompt(date, prompt, tags)` - создание нового промпта
- `get_all_prompts()` - получение всех промптов
- `get_prompt_by_id(id)` - получение промпта по ID
- `update_prompt(id, date, prompt, tags)` - обновление промпта
- `delete_prompt(id)` - удаление промпта
- `search_prompts(query)` - поиск по промптам
- `sort_prompts(field, order)` - сортировка промптов

2.3. Реализовать CRUD операции для таблицы `models`:
- `create_model(name, api_url, api_id, is_active)` - создание модели
- `get_all_models()` - получение всех моделей
- `get_active_models()` - получение только активных моделей
- `update_model(id, name, api_url, api_id, is_active)` - обновление модели
- `delete_model(id)` - удаление модели
- `toggle_model_active(id, is_active)` - переключение активности модели
- `search_models(query)` - поиск по моделям

2.4. Реализовать CRUD операции для таблицы `results`:
- `save_result(prompt_id, model_name, response_text)` - сохранение результата
- `get_all_results()` - получение всех результатов
- `get_results_by_prompt_id(prompt_id)` - получение результатов по промпту
- `delete_result(id)` - удаление результата
- `search_results(query)` - поиск по результатам
- `sort_results(field, order)` - сортировка результатов

2.5. Реализовать операции для таблицы `settings`:
- `get_setting(key)` - получение настройки
- `set_setting(key, value)` - сохранение настройки
- `get_all_settings()` - получение всех настроек

## Этап 3: Работа с моделями (models.py)

3.1. Создать класс Model для представления модели нейросети:
- Атрибуты: id, name, api_url, api_id, is_active
- Методы для работы с данными модели

3.2. Реализовать функции:
- `load_models_from_db()` - загрузка моделей из БД
- `get_active_models_list()` - получение списка активных моделей
- `validate_model_config(model)` - проверка конфигурации модели

## Этап 4: Сетевые запросы (network.py)

4.1. Реализовать функцию загрузки API-ключей из .env:
- `load_api_keys()` - чтение переменных окружения
- Обработка отсутствующих ключей

4.2. Реализовать универсальную функцию отправки запроса:
- `send_request_to_model(model, prompt, api_key)` - отправка промпта в модель
- Поддержка разных типов API (OpenAI, DeepSeek, Groq и т.д.)
- Обработка ошибок сети и таймаутов
- Возврат ответа или ошибки

4.3. Реализовать параллельную отправку запросов:
- `send_to_all_models(models, prompt)` - отправка в несколько моделей одновременно
- Использование threading или asyncio для параллельности
- Обработка частичных ошибок (если одна модель не ответила)

## Этап 5: Графический интерфейс (main.py)

5.1. Создать главное окно приложения:
- Класс `MainWindow(QMainWindow)`
- Настройка размеров и заголовка окна

5.2. Реализовать панель ввода промпта:
- Текстовое поле для ввода нового промпта
- Выпадающий список для выбора сохранённого промпта
- Кнопка "Отправить"
- Поле для тегов (опционально)

5.3. Реализовать таблицу результатов:
- QTableWidget для отображения временных результатов
- Колонки: "Модель", "Ответ", "Выбрано" (чекбокс)
- Автоматическое обновление при получении ответов
- Индикатор загрузки во время отправки запросов

5.4. Реализовать кнопки управления:
- "Сохранить" - сохранение выбранных результатов в БД
- "Очистить" - очистка временной таблицы
- "Новый запрос" - сброс и подготовка к новому промпту

5.5. Реализовать меню и дополнительные окна:
- Меню "Модели" - управление моделями (добавление, редактирование, активация)
- Меню "Промпты" - просмотр и управление сохранёнными промптами
- Меню "Результаты" - просмотр сохранённых результатов
- Меню "Настройки" - настройки приложения
- Окно добавления/редактирования модели
- Окно просмотра истории промптов

5.6. Реализовать функциональность поиска и сортировки:
- Поиск в таблицах промптов, моделей и результатов
- Сортировка по колонкам
- Фильтры для активных/неактивных моделей

## Этап 6: Интеграция компонентов

6.1. Связать GUI с модулем базы данных:
- При запуске инициализировать БД
- Загружать список промптов и моделей при открытии окон

6.2. Интегрировать сетевые запросы:
- При нажатии "Отправить" вызывать network.py
- Обновлять таблицу результатов по мере получения ответов
- Обрабатывать ошибки и показывать их пользователю

6.3. Реализовать сохранение результатов:
- При нажатии "Сохранить" записывать выбранные строки в БД
- Очищать временную таблицу после сохранения

## Этап 7: AI-ассистент для улучшения промптов

7.1. Создать модуль для работы с улучшением промптов:
- Файл `prompt_improver.py` - модуль для логики улучшения промптов
- Функция `improve_prompt(prompt_text, model_name, api_key)` - основная функция улучшения
- Функция `generate_alternatives(prompt_text, model_name, api_key)` - генерация альтернативных вариантов
- Функция `adapt_for_model_type(prompt_text, model_type)` - адаптация под типы моделей (код, анализ, креатив)

7.2. Реализовать промпт-шаблоны для улучшения:
- Создать системные промпты для улучшения промптов
- Промпт для генерации улучшенной версии
- Промпт для генерации 2-3 альтернативных вариантов
- Промпт для адаптации под разные типы задач (код, анализ, креатив)

7.3. Реализовать функцию отправки запроса на улучшение:
- Использовать существующий OpenRouter-клиент из `network.py`
- Отправка промпта в выбранную модель для улучшения
- Парсинг ответа модели (улучшенный промпт + варианты)
- Обработка ошибок и таймаутов

7.4. Создать UI компоненты для улучшения промптов:
- Кнопка "Улучшить промт" рядом с полем ввода промпта в `main.py`
- Диалоговое окно `PromptImproverDialog(QDialog)` для отображения результатов:
  - Область с исходным промптом (только для чтения)
  - Область с улучшенным промптом
  - Список альтернативных вариантов (2-3 варианта)
  - Кнопки "Подставить улучшенный" и "Подставить вариант N"
  - Кнопка "Закрыть"
- Интеграция кнопки в главное окно рядом с полем ввода

7.5. Реализовать логику выбора модели для улучшения:
- Выпадающий список моделей в диалоге улучшения
- По умолчанию использовать модель из настроек или первую активную
- Возможность выбора конкретной модели для улучшения

7.6. Реализовать парсинг ответа модели:
- Парсинг JSON-ответа (если модель возвращает структурированный ответ)
- Парсинг текстового ответа с разделением на улучшенный промпт и варианты
- Обработка разных форматов ответов от разных моделей
- Извлечение улучшенного промпта и альтернативных вариантов

7.7. Реализовать функциональность "Подставить в поле ввода":
- При клике на кнопку "Подставить" выбранный вариант вставляется в поле ввода промпта
- Закрытие диалога после подстановки
- Сохранение фокуса на поле ввода

7.8. Добавить индикацию процесса улучшения:
- Индикатор загрузки во время отправки запроса
- Блокировка кнопки "Улучшить промт" во время обработки
- Отображение ошибок при неудачном улучшении

7.9. Оптимизация и улучшения:
- Кэширование результатов улучшения для одинаковых промптов
- Возможность сохранения улучшенного промпта в таблицу prompts
- История улучшений (опционально)

## Этап 8: Дополнительные функции

8.1. Реализовать экспорт результатов:
- Экспорт в Markdown формат
- Экспорт в JSON формат
- Выбор файла для сохранения через диалог

8.2. Реализовать логирование:
- Модуль `logger.py` для логирования запросов
- Сохранение логов в файл
- Отображение логов в интерфейсе (опционально)

8.3. Добавить поддержку разных типов API:
- Адаптеры для OpenAI API
- Адаптеры для DeepSeek API
- Адаптеры для Groq API
- Универсальный интерфейс для добавления новых типов

## Этап 9: Тестирование и отладка

9.1. Протестировать работу с БД:
- Создание, чтение, обновление, удаление записей
- Поиск и сортировка

9.2. Протестировать сетевые запросы:
- Отправка запросов в разные модели
- Обработка ошибок сети
- Таймауты

9.3. Протестировать GUI:
- Все кнопки и меню
- Обновление таблиц
- Сохранение результатов

9.4. Протестировать функцию улучшения промптов:
- Отправка запросов на улучшение
- Парсинг ответов от разных моделей
- Работа диалога улучшения
- Подстановка вариантов в поле ввода

9.5. Интеграционное тестирование:
- Полный цикл работы приложения
- Обработка граничных случаев

## Этап 10: Финальная доработка

10.1. Оптимизация производительности:
- Кэширование данных
- Оптимизация запросов к БД

10.2. Улучшение UX:
- Подсказки и tooltips
- Валидация ввода
- Сообщения об ошибках

10.3. Документация:
- Обновление README.md
- Комментарии в коде
- Инструкции по использованию

10.4. Подготовка к релизу:
- Создание .gitignore
- Подготовка requirements.txt
- Создание исполняемого файла (опционально)
