# План реализации программы ChatList

## Этап 1: Подготовка проекта и структуры

1.1. Создать структуру проекта:
- `main.py` - главный файл с GUI интерфейсом
- `db.py` - модуль для работы с базой данных SQLite
- `models.py` - модуль для работы с моделями нейросетей
- `network.py` - модуль для отправки HTTP-запросов к API
- `config.py` - модуль для работы с настройками и переменными окружения
- `.env` - файл с API-ключами (добавить в .gitignore)
- `requirements.txt` - зависимости проекта

1.2. Установить зависимости:
- PyQt5 для GUI
- requests/httpx для HTTP-запросов
- python-dotenv для работы с .env файлом
- sqlite3 (встроенная библиотека Python)

## Этап 2: Реализация базы данных (db.py)

2.1. Создать функции инициализации БД:
- `init_database()` - создание файла БД и всех таблиц
- Проверка существования БД при первом запуске

2.2. Реализовать CRUD операции для таблицы `prompts`:
- `create_prompt(date, prompt, tags)` - создание нового промпта
- `get_all_prompts()` - получение всех промптов
- `get_prompt_by_id(id)` - получение промпта по ID
- `update_prompt(id, date, prompt, tags)` - обновление промпта
- `delete_prompt(id)` - удаление промпта
- `search_prompts(query)` - поиск по промптам
- `sort_prompts(field, order)` - сортировка промптов

2.3. Реализовать CRUD операции для таблицы `models`:
- `create_model(name, api_url, api_id, is_active)` - создание модели
- `get_all_models()` - получение всех моделей
- `get_active_models()` - получение только активных моделей
- `update_model(id, name, api_url, api_id, is_active)` - обновление модели
- `delete_model(id)` - удаление модели
- `toggle_model_active(id, is_active)` - переключение активности модели
- `search_models(query)` - поиск по моделям

2.4. Реализовать CRUD операции для таблицы `results`:
- `save_result(prompt_id, model_name, response_text)` - сохранение результата
- `get_all_results()` - получение всех результатов
- `get_results_by_prompt_id(prompt_id)` - получение результатов по промпту
- `delete_result(id)` - удаление результата
- `search_results(query)` - поиск по результатам
- `sort_results(field, order)` - сортировка результатов

2.5. Реализовать операции для таблицы `settings`:
- `get_setting(key)` - получение настройки
- `set_setting(key, value)` - сохранение настройки
- `get_all_settings()` - получение всех настроек

## Этап 3: Работа с моделями (models.py)

3.1. Создать класс Model для представления модели нейросети:
- Атрибуты: id, name, api_url, api_id, is_active
- Методы для работы с данными модели

3.2. Реализовать функции:
- `load_models_from_db()` - загрузка моделей из БД
- `get_active_models_list()` - получение списка активных моделей
- `validate_model_config(model)` - проверка конфигурации модели

## Этап 4: Сетевые запросы (network.py)

4.1. Реализовать функцию загрузки API-ключей из .env:
- `load_api_keys()` - чтение переменных окружения
- Обработка отсутствующих ключей

4.2. Реализовать универсальную функцию отправки запроса:
- `send_request_to_model(model, prompt, api_key)` - отправка промпта в модель
- Поддержка разных типов API (OpenAI, DeepSeek, Groq и т.д.)
- Обработка ошибок сети и таймаутов
- Возврат ответа или ошибки

4.3. Реализовать параллельную отправку запросов:
- `send_to_all_models(models, prompt)` - отправка в несколько моделей одновременно
- Использование threading или asyncio для параллельности
- Обработка частичных ошибок (если одна модель не ответила)

## Этап 5: Графический интерфейс (main.py)

5.1. Создать главное окно приложения:
- Класс `MainWindow(QMainWindow)`
- Настройка размеров и заголовка окна

5.2. Реализовать панель ввода промпта:
- Текстовое поле для ввода нового промпта
- Выпадающий список для выбора сохранённого промпта
- Кнопка "Отправить"
- Поле для тегов (опционально)

5.3. Реализовать таблицу результатов:
- QTableWidget для отображения временных результатов
- Колонки: "Модель", "Ответ", "Выбрано" (чекбокс)
- Автоматическое обновление при получении ответов
- Индикатор загрузки во время отправки запросов

5.4. Реализовать кнопки управления:
- "Сохранить" - сохранение выбранных результатов в БД
- "Очистить" - очистка временной таблицы
- "Новый запрос" - сброс и подготовка к новому промпту

5.5. Реализовать меню и дополнительные окна:
- Меню "Модели" - управление моделями (добавление, редактирование, активация)
- Меню "Промпты" - просмотр и управление сохранёнными промптами
- Меню "Результаты" - просмотр сохранённых результатов
- Меню "Настройки" - настройки приложения
- Окно добавления/редактирования модели
- Окно просмотра истории промптов

5.6. Реализовать функциональность поиска и сортировки:
- Поиск в таблицах промптов, моделей и результатов
- Сортировка по колонкам
- Фильтры для активных/неактивных моделей

## Этап 6: Интеграция компонентов

6.1. Связать GUI с модулем базы данных:
- При запуске инициализировать БД
- Загружать список промптов и моделей при открытии окон

6.2. Интегрировать сетевые запросы:
- При нажатии "Отправить" вызывать network.py
- Обновлять таблицу результатов по мере получения ответов
- Обрабатывать ошибки и показывать их пользователю

6.3. Реализовать сохранение результатов:
- При нажатии "Сохранить" записывать выбранные строки в БД
- Очищать временную таблицу после сохранения

## Этап 7: Дополнительные функции

7.1. Реализовать экспорт результатов:
- Экспорт в Markdown формат
- Экспорт в JSON формат
- Выбор файла для сохранения через диалог

7.2. Реализовать логирование:
- Модуль `logger.py` для логирования запросов
- Сохранение логов в файл
- Отображение логов в интерфейсе (опционально)

7.3. Добавить поддержку разных типов API:
- Адаптеры для OpenAI API
- Адаптеры для DeepSeek API
- Адаптеры для Groq API
- Универсальный интерфейс для добавления новых типов

## Этап 8: Тестирование и отладка

8.1. Протестировать работу с БД:
- Создание, чтение, обновление, удаление записей
- Поиск и сортировка

8.2. Протестировать сетевые запросы:
- Отправка запросов в разные модели
- Обработка ошибок сети
- Таймауты

8.3. Протестировать GUI:
- Все кнопки и меню
- Обновление таблиц
- Сохранение результатов

8.4. Интеграционное тестирование:
- Полный цикл работы приложения
- Обработка граничных случаев

## Этап 9: Финальная доработка

9.1. Оптимизация производительности:
- Кэширование данных
- Оптимизация запросов к БД

9.2. Улучшение UX:
- Подсказки и tooltips
- Валидация ввода
- Сообщения об ошибках

9.3. Документация:
- Обновление README.md
- Комментарии в коде
- Инструкции по использованию

9.4. Подготовка к релизу:
- Создание .gitignore
- Подготовка requirements.txt
- Создание исполняемого файла (опционально)
